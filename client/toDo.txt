--High Priority--
make sure dealer tag rotates between games
fix bug where if a CurrentRound is partially complete, and user clicks 'New Game', it does not clear the roundState. it only clears roundHistory. The button state does not get cleared. The fix: userReducer for global state 
validation for total Actuals being more than 13. Create modal containing all 4 player's actuals. It should have a 'done' button that checks for validation. If validation fails again, keep modal open.
implement validation for name length and team length such that it won't create layout issues on small mobile devices. consider also adding CSS that makes longer names possible without messing up the layout
make sure bidding is saved to localStorage as soon as the last bid is entered. This will require making another localStorage object currentRound
redo UI for currentRound to make it resemble a table 
make sure all instances of useLocalStorage are converted to redux. Or at least consider whether it makes sense to use both

--Backlog--
see if it's possible to architect my app in such a way that past rounds and current rounds don't need to be logically separate. We could simply have a single history array that always stores to localStorage
hook up useReducer for names, and nilScoringRule form state. 
is passing 'isCurrent' prop down a code smell? consider refactoring for better separation of concerns for currentRound vs pastround. See onSelect function inside ButtonGrid.jsx
refactor getCurrentDealerId
now that I've moved currentRound state into global state with Context, make sure to remove any code from when it was hooked up to local component state
i have resetCurrentRound() being invoked in both onContinue and onSameTeams. The user sometimes clicks onContinue before 'onSameTeams' button so the user sometimes sets state twice in a row? Is there a better solution for this, or is this pretty normal?
getCurrentDealerId is an ugly function that's hard to reason about. refactor after currentRound vs pastround has been thoroughly sorted out.
is getTeamClassName a bad solution for conditional styling?
add proper theming for default chakraUI components
instead of writing style into html body tag, look into injectGlobal function from styled-components
simplify spadesMath - make sure calculateTeamScoreFromRoundHistory doesn't require both teams. It should just be calculateTeamScoreFromRoundHistory. add class for spadesMath, and extend that class to add other settings for how game is scored
Address comments on whoWentNil function
make it more obvious that team names are editable and that past rounds are editable. when someone bids, the button turns into text of what they bid. Keep it as a button so that users understand that it's editable
add color theme to more clearly delineate teams (so that users don't accidentally enter data for the wrong team)
implement typescript
clean up WarningModal.jsx
figure out what to do with functions that require a lot of parameters
change text for past rounds. Instead of saying 'someone's getting set', say 'someone got set'. Or even, 'Team 1 got set'
address console warnings and audit fix dependency problems
add text to PastRound Actuals. if someone went over 10 bags, or got set, or failed nil, let user know
improve separation of concerns for CurrentRound vs PastRound
names was already set in NameForm.js. Consider making global state that I can grab from for cleaner solution than reaching for localStorage names in SpadesCalculator
test whether a change to localStorage variable name will cause app crash for someone who already has deprecated variable name stored on their localStorage
improve design
implement accordions for past rounds, except for the most recent past round. That one should always be open because it's the most common past round to inquire about
consider adding more info to RoundSummary: [game score at start of round (but find a way to make it shorter), game score at end of round, bags taken, total bags at current round]. If I implement a lot of this, then make a drawer component that sits within RoundSummary
make sure that the RoundSummary for the most recent past round is fully within view on all mobile devices
add animation for when last bidsAndActuals is entered. Would be nice if a finished round would slide downward as the next CurrentRound is initialized
make layout responsive for tablet/desktop usage
make ActualsSection conditional. It should only show when all bids are entered. It should also animate downwards.
make team names editable on SpadesCalculator page
optimize app - make sure there are no unnecessary re-renders
provide source on failed nil (https://www.trickstercards.com/home/help/HowToPlay.aspx?game=spades)
consider implementing even more game setting options
add more tests for calculateTeamRoundScoresFromTeamHistory, calculateTeamScoreFromRoundHistory and different failed-nil settings
clean up BidSection Heading. Maybe split it into more components
buggy behavior when I try to move useSetScoreWhenRoundIsFinished into the hooks.js file. I get an infinite loop after inputting all of the second round's inputs. Figure out why
go through codebase looking for comments. Add them to the backlog and then delete the comments
In CurrentRound.jsx, isCurrent is being passed as a prop but maybe isCurrent should be defined from within BidSection in the form of state. Each instance of BidSection will have an isCurrent state that mounts true, but when it unmounts (or is added to roundHistory), then it switches to false. 


Matt's suggestions:
make sure that PastRound and CurrentRound don't know or set gameScore
BidsAndActuals should only be inside of currentRound or PastRound

 /* 
  try to set the state from within handler rather than useEffect. And when you 
  call a setState, 
  */
  // const handleBid = useCallback((bid, player) => {
  //   if (player === 1) {
  //     setT1p1Bid(bid, () => {
  //       /* stick logic from useEffect
  //   combine bid state and actual state into one state
  //   */
  //     });
  //   } else if (player === 2) {
  //   }
  // }, []);
  // const handleActual = useCallback((actual, player) => {}, []);