import {
  possibleActuals,
  possibleBids,
  team1Styles,
  team2Styles,
} from "./constants";

import type {
  Round,
  UpdateInputArgs,
  TeamBidsAndActuals,
  TeamColorStyle,
} from "../../types";

export function getActualsErrorText(totalActuals: number) {
  const difference = 13 - totalActuals;
  const num = Math.abs(difference);
  const moreOrLess = difference >= 0 ? "more" : "less";

  return `The total amount of hands must always add up to 13. Yours totaled ${totalActuals}. You need ${num} ${moreOrLess} to continue.`;
}

export function sIfPlural(num: number) {
  return num > 1 ? "s" : "";
}

export function getUnclaimedText(numUnclaimed: number, useTableUI = false) {
  const isSomeoneGettingSet = numUnclaimed < 0;
  if (isSomeoneGettingSet) {
    const numOverbid = Math.abs(numUnclaimed);
    if (useTableUI) {
      return `Overbids: ${numOverbid}`;
    }
    return `${numOverbid} overbid${sIfPlural(
      numOverbid,
    )}! Someone's getting set!`;
  }
  return `Unclaimed: ${numUnclaimed}`;
}

export const getButtonValues = (type: "Bid" | "Actual") => {
  if (type === "Bid") {
    return possibleBids;
  }
  return possibleActuals;
};

export const getTeamStyle = (teamName: string): TeamColorStyle => {
  const storedNames = localStorage.getItem("names");
  if (!storedNames) return team1Styles;
  const { team1Name } = JSON.parse(storedNames);
  return teamName === team1Name ? team1Styles : team2Styles;
};

// consider renaming
export const updateInput = ({
  input,
  currentRound,
  fieldToUpdate,
}: UpdateInputArgs): Round => {
  const [teamKey, playerKey] = fieldToUpdate.split(".") as [
    "team1BidsAndActuals" | "team2BidsAndActuals",
    keyof TeamBidsAndActuals,
  ];
  return {
    ...currentRound,
    [teamKey]: {
      ...currentRound[teamKey],
      [playerKey]: input,
    },
  };
};

interface GetEditedRoundHistoryArgs {
  index: number;
  updatedRound: Round;
  roundHistory: Round[];
}

export const getEditedRoundHistory = ({
  index,
  updatedRound,
  roundHistory,
}: GetEditedRoundHistoryArgs) => {
  if (!Array.isArray(roundHistory)) {
    console.warn("Invalid roundHistory passed to getEditedRoundHistory");
    return [updatedRound];
  }
  const clonedRoundHistory = [...roundHistory];
  clonedRoundHistory[index] = updatedRound;
  return clonedRoundHistory;
};

/* 
if there's anything in localStorage, then return that value;
otherwise, set a default value for that key in localStorage
*/
export const defaultLocalStorage = <T>(key: string, value: T): T => {
  const item = window.localStorage.getItem(key);
  if (!item) {
    window.localStorage.setItem(key, JSON.stringify(value));
    return value;
  }
  return JSON.parse(item);
};

export const getLocalStorage = <T>(key: string): T | null => {
  const item = window.localStorage.getItem(key);
  if (!item) return null;
  return JSON.parse(item);
};

export const setLocalStorage = <T>(key: string, value: T) => {
  window.localStorage.setItem(key, JSON.stringify(value));
};

export const rotateArr = <T>(arr: T[]): T[] => {
  if (arr.length <= 1) return [...arr];
  return [...arr.slice(1), arr[0]];
};

export function isActualAutoGenerated(
  fieldToUpdate: string,
  round: Round | null,
  type: string,
): boolean {
  if (type !== "Actual") return false;
  if (!round?.autoGeneratedActuals) return false;
  const isTeam1 = fieldToUpdate.includes("team1");
  const isP1 = fieldToUpdate.includes("p1");
  const key =
    `team${isTeam1 ? 1 : 2}P${isP1 ? 1 : 2}` as keyof Round["autoGeneratedActuals"];
  return round.autoGeneratedActuals[key] === true;
}

export function hasAnyAutoGeneratedActuals(round: Round | null): boolean {
  if (!round?.autoGeneratedActuals) return false;
  return Object.values(round.autoGeneratedActuals).some(
    (value) => value === true,
  );
}
